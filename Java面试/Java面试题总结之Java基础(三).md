### 1. 谈谈对象的访问定位
对象创建起来之后，就会在虚拟机栈中维护一个本地变量表，用于存储基础类型和基础类型的值，引用类型与引用类型的值。
其中引用类型的值就是堆中对象地址。如何引用堆中地址有两种方式：
* 句柄：在堆中维护一个句柄池，句柄中包含了对象地址，当对象改变的时候，只需改变句柄，不需要改变栈中本地变量表的引用
* 直接指针：对象的地址直接存储在栈中，这样做的好处就是访问速度变快（Hotspot采用该方式）


### 2. JVM将内存主要划分为哪五部分
方法区、虚拟机栈、本地方法栈、堆、程序计数器。

### 3. String的intern()函数作用
这个要分版本来回答：

* 如果是JDK6，如果字符串产量池先前已经创建该对象，则返回引用；否则将其添加到字符串常量池并返回引用。
* 如果是JDK6+，若字符串常量池有则返回引用，如果池中没有堆中有，则将堆中的引用添加到池中(注意是引用),然后返回引用；若池中也没有，则在池中创建并返回引用。

### 4. 本地方法栈和虚拟机栈区别
本地方法栈与虚拟机栈所发挥的作用很相似，他们的区别在于虚拟机栈为执行Java代码方法服务，而本地方法栈是为Native方法服务。

### 5. 分配堆内存指令
```
-Xms -Xmx
```
前者是堆的初始值，后者是堆能达到的最大值。
### 6. 程序计数器作用
记录当前线程锁执行的字节码的行号。
1. 程序计数器是一块较小的内存空间。
2. 处于线程独占区。
3. 执行java方法时，它记录正在执行的虚拟机字节码指令地址。执行native方法，它的值为undefined
4. 该区域是唯一一个没有规定任何OutOfMemoryError的区域


### 7. 如何将字符串反转？

* 通过 charAt(int index)返回char值进行字符串拼接
* 调用StringBuffer中的reverse方法


### 8. Collection 和 Collections 有什么区别？

* Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法，直接继承接口的有list和set集合。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。

* Collections 是Java派生的主要集合类的两个之一，另一个是map接口。其是一个服务于collection的包装类，不能实例化。它包含有各种有关集合操作的静态多态方法,如排序、复制、搜索。

### 9. 在 Queue 中 poll()和 remove()有什么区别？
1. queue的增加元素方法add和offer的区别在于，add方法在队列满的情况下将选择抛异常的方法来表示队列已经满了，而offer方法通过返回false表示队列已经满了；在有限队列的情况，使用offer方法优于add方法；
2. remove方法和poll方法都是删除队列的头元素，remove方法在队列为空的情况下将抛异常，而poll方法将返回null；
3. element和peek方法都是返回队列的头元素，但是不删除头元素，区别在与element方法在队列为空的情况下，将抛异常，而peek方法将返回null.


### 10. 什么是迭代器

Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包括了可以返回迭代器实例的迭代方法。迭代器可以在迭代过程中删除底层集合的元素，但是不可以直接调用集合的remove(Object obj)删除，可以通过迭代器的remove()方法删除

### 11. 迭代器的优点

如果用的是for循环，就用集合自带的remove(),而这样就改变了集合的Size（）循环的时候会出错。但如果把集合放入迭代器，既iterator迭代可以遍历并选择集合中的每个对象而不改变集合的结构，而把集合放入迭代器，用迭代器的remove（）就不会出现问题

### 12. Java集合类中的Iterator和ListIterator的区别

对List来说，你也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator和ListIterator主要区别在以下方面：
1. iterator()方法在set和list接口中都有定义，但是ListIterator()仅存在于list接口中（或实现类中）；

2. ListIterator有add()方法，可以向List中添加对象，而Iterator不能

3. ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。

4. ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。

5. 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。　　


### 13. 怎么确保一个集合不能被修改？
1. Java中提供final关键字，对基本类型进行修饰，当第一次初始化后，该变量就不可被修改
2. `Collections`工具类中的`UnmodifiableList`(不可修改的List、Map、Set等)


### 14. 并行和并发区别

并发的关键是你有处理多个任务的能力，不一定要同时。  

### 15. 说一下你对Daemon线程(守护线程)的理解？它有什么意义？一般应用于什么样的场景？


所谓守护线程是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因 此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。

守护线程和用户线程的没啥本质的区别：唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。将用户线程转化为守护线程的方法：X.setDaemon(true)，须在线程start()方法前执行。

还有一个启动守护线程的方法就是利用Timer和TimerTask。Timer是JDK提供的定时器工具，使用时会在主线程之外单独起一个线程执行指定的任务。Timer timer = new Timer()启动的是用户线程，而Timer timer = new Timer(true)启动的就是守护线程。TimerTask是一个实现了Runnable接口的抽象类，配合Timer使用可以看做被Timer执行的任务，即启动的线程。注意守护线程中产生的线程都是守护线程。


### 16. sleep() 和 wait() 有什么区别？

* 对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。

* 而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。



### 17. notify 和 notifyAll 区别

notify 仅仅通知一个线程，并且我们不知道哪个线程会收到通知，然而 notifyAll 会通知所有等待中的线程。换言之，如果只有一个线程在等待一个信号灯，notify和notifyAll都会通知到这个线程。但如果多个线程在等待这个信号灯，那么notify只会通知到其中一个，而其它线程并不会收到任何通知，而notifyAll会唤醒所有等待中的线程。


### 18. 线程中start()和run()的区别

多线程就是分时利用CPU，宏观上让所有线程一起执行，也叫并发。

* 每个线程都有要执行的任务。线程的任务处理逻辑可以在Tread类的run实例方法中直接实现或通过该方法进行调用，因此run()相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。

* 而start()的作用是启动相应的线程。调用start()后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。然后通过JVM，线程Thread会调用run()方法，执行本线程的线程体。

#### 为什么不直接调用run？
start()方法来启动线程，才真正实现了多线程运行。若直接使用run()方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码。


### 19. 线程池的五种状态
线程池的5种状态：
1. Running：能够接收新任务，以及对已添加的任务进行处理。线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0。
2. ShutDown：不接收新任务，但能处理已添加的任务。 调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。
3. Stop：不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。
4. Tidying：所有的任务已终止，ctl记录的”任务数量”为0，同时执行钩子函数terminated()。
    - 当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。
    - 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。
5. Terminated:线程池彻底终止。线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。

### 20. 线程池中 submit()和 execute()方法有什么区别？
* execute(Runnable x) 没有返回值。可以执行任务，但无法判断任务是否成功完成。——实现Runnable接口

* submit(Runnable x) 返回一个future。可以用这个future来判断任务是否成功完成。——实现Callable接口

