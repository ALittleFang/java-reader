### 并发与并行
+ **并发（Concurrency）**: 当有多个线程在操作时，如果系统只有一个CPU，则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。
+ **并行（Parallellism）**: 当系统有一个以上CPU时，一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行。

### 临界区
**临界区**用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。

### 阻塞（Blocking）和非阻塞（Non-Blocking）
+ **阻塞**: 比如一个线程占用了临界区资源，那么其它所有需要这个资源的线程就必须在这个临界区外进行等待，等待会导致线程挂起。这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其它所有阻塞在这个临界区上的线程都不能工作。
+ **非阻塞**: 允许多个线程同时进入临界区，或者在遇到需要等待的时刻，不等待而选择去做其他的事情。

### 同步和异步
同步和异步是相对于操作结果来说，会不会等待结果返回。例如同步就是烧开水，需要自己去轮询（每隔一段时间去看看水开了没），异步就是水开了，然后水壶会通知你水已经开了，你可以回来处理这些开水了。

### 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）
+ 死锁： 一个线程需要获取多个资源的时候，这时由于两个线程互相等待对方的资源而被阻塞。简单来说，比如你去面试面试官问：你告诉我什么是死锁，我就录用你，而你回答：你录用我，我就告诉你什么是死锁！
+ 活锁： 任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。**解决活锁的办法是在每次重复执行的时候引入随机机制，这样由于出现的可能性不同使得程序可以继续执行其他的任务**。例如我有资格坐电梯，但是这趟电梯已经满人超载了，我要继续等！
+ 饥饿：指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况。如电梯等人

#### 活锁和死锁的区别
处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。
